Crear un proyecto
	Ir a la carpeta que va a contener a la Carpeta [NOMBRE_PROYECTO]
		Es decir, la l칤nea de abajo crea la carpeta [NOMBRE_PROYECTO] y pone todos los archivos adentro
	npx create-next-app [NOMBRE_PROYECTO]

	No es obligaci칩n trabajar con TS 

	Poner `src/` directory = "S칤" cuando los proyectos sean relativamente grandes y puedan ir creciendo

	App Router: Yes

	TurboPack: Yes

	Customize import alias: No
	
Ejecutar un proyecto
	npm run dev

Crear una p치gina nueva en una direcci칩n
	Por ejemplo www.com.ar/about
		En /app creo la carpeta /about y dentro el componente page.tsx con el siguiente contenido
		
		export default function AboutPage(){
		    return (
		        <>
		            <span className="text-7xl">About page</span>
		        </>
		    )
		}

	Eso ya arma la ruta autom치ticamente para navegar por navegador

Cambiar HTML/head/title y meta-description
	Abrir /app/layout y modificar export const metadata: Metadata = {

	Esto lo cambia a nivel global

	IMPORTANTE:
		Configurar como m칤nimo el t칤tulo y la descripci칩n

	Puedo cambiarlo en cada p치gina:
		Abrir uno de los componentes, por ejemplo /app/about/page.tsx y por fuera de la exportaci칩n poner:
			export const metadata = {
			    title: 'Acerca de | Mi proyecto',
			    description: 'Acerca de | Descripci칩n de mi proyecto',
			};

Layouts distintos para diferentes p치ginas
	Puedo poner un layout.tsx dentro de la carpeta donde quiero modificar el dise침o. Ese layout es un HOC, donde el children es la p치gina que quiero renderizar.
		En ese HOC tengo que implementar el children donde lo quiera renderizar

	Si quiero tener un solo layout para m칰ltiples carpetas puedo tener esta estructura de archivos:

	/
	|_app
	     |_(general)
			|_about
			|_contact
			|_pricing
			|_layout.tsx // <--- Este layout impacta sobre las tres carpetas. Se le pone (general) para que no agregue "general" a la URL
	     |_layout.tsx	// Layout y
	     |_page.tsx		// Home page




UsePathname
	Sirve para saber el path en el que estoy
	Es un componente del lado del cliente, por lo cual si quiero usarlo tengo que poner 'use client' en la parte superior

Publicaci칩n de proyecto
	1) Build del proyecto
		Cancelar la ejecuci칩n del proyecto y correr: npm run build

Redireccionar a una URL dentro del proyecto por c칩digo
	redirect('/dashboard/counter')
		Esto redirecciona a esa p치gina puntual, entiendo que es un comando del servidor

NextImage
	Cambiar <img por <Image
				src="/profile.png"
				width={500}
				height={500}
				alt="Picture of the author"
			/>

	Para poner im치genes hosteadas en otro sitio
		En /next.config.ts
			const nextConfig: NextConfig = {
			  images: {
			    remotePatterns: [
			      {
			        protocol: 'https',
			        hostname: 'images.unsplash.com'
			      }
			    ]
			  }
			};

	Se puede hacer que una imagen se cargue cuando entre al viewport, para eso poner la propiedad
		priority={false}

Armar una ruta que reciba un par치metro
	Dentro de la carpeta que quiero contener esa p치gina creo el archivo:
		pokemon/[id]/page.tsx

Puedo configurar el cach칠 al momento de hacer un fetch():
	const pokemon = await fetch(`https://pokeapi.co/api/v2/pokemon/${id}`, {
		cache: '' // <--- Ac치 estan todas las opciones
	}) // "no-store" es que cada vez que entre a la p치gina, se haga la solicitud

Metadata din치mica (5/59)
	Usar funci칩n generateMetadata (es una funci칩n reservada de Next)
		export async function generateMetadata({params}:Props): Promise<Metadata>{
		  try{
		    const {id, name} = await getPokemon(params.id)
		
		    return {
		        title: `#${id} - ${name}`,
		        description: `P치gina del Pok칠mon ${name}`
		    }
		  }catch(ex){
		    return {
		        title: `P치gina del Pokemon`,
		        description: `Descripci칩n del Pokemon`
		    }
		  }
		}

	Esto va fuera de la exportaci칩n del componente

Cargar im치genes desde otros dominios
	/next.config.ts
		Agregar en remotePatterns:
			const nextConfig: NextConfig = {
			  images: {
			    remotePatterns: [
			      {
			        protocol: 'https',
			        hostname: 'images.unsplash.com'
			      },
			      {
			        protocol: 'https',
			        hostname: 'raw.githubusercontent.com'
			      }
			    ]
			  }
			};

Not found personalizado a cada carpeta (5/62)
	Copiar un archivo not-found (es estandar) a la carpeta que quiero aplicar

Generaci칩n est치tica y revalidaci칩n (5/69)
	Se pueden generar de antemano, est치ticamente, p치ginas din치micas que reciben un ID, para servirlas est치ticamente.
		Esa generaci칩n se produce en Build Time (npm run build)

	Para eso, se ejecuta una funci칩n que se llama generateStaticParams, la cual devuelve un array est치tico con los par치metros que espera la p치gina din치mica para que genere din치micamente en tiempo de construcci칩n todas esas p치ginas est치ticas.

	En el ejemplo 5/62 la p치gina din치mica espera el par치metro id, entonces mi funci칩n generateStaticParams va a ser as칤:
		export async function generateStaticParams() {
		  return [
		    { id: '1' },
		    { id: '2' },
		    { id: '3' },
		    { id: '4' },
		    { id: '5' },
		    { id: '6' }
		  ];

	Al tener esto, y ejecutar npm run build, de antemano Next genera las p치ginas est치ticas para los casos donde se reciban par치metros del 1 al 6, entonces no tiene que volver a generarlas cuando el usuario las visite. En caso que el usuario ingrese id: 7, se genera esa p치gina tambi칠n.

	En este ejemplo tenemos:
		try {
		    const pokemon = await fetch(`https://pokeapi.co/api/v2/pokemon/${id}`, {
		      //cache: 'force-cache'
		      next: {
		        revalidate: 60 * 60 * 24 * 30 * 6
		      }
		    }).then(resp => resp.json());

	Esto hace que Next revalide cada X segundos (60 * 60 * 24 * 30 * 6 = 6 meses). Funciona porque Next, al momento de servir la p치gina rastrea si existen fetchs que se deban revalidar. Si no hay que revalidar, sirve la versi칩n actual, si expir칩 validaci칩n la regenera y sirve la nueva versi칩n.

	Si se quiere revalidar una p치gina independientemente del fetch se puede poner esta instrucci칩n fuera de la exportaci칩n del componente:
		export const revalidate = 60 * 60 * 30 * 6;



Redux Toolkit para manejo global
	Primero instala redux toolkit desde https://redux-toolkit.js.org/tutorials/quick-start
		npm install @reduxjs/toolkit react-redux

	(IMPORTANTE 游녢 7/80)
	A priori un buen lugar para poner el <Provider> ser칤a en el layout.tsx de la app principal: /src/app/layout.tsx:
		export default function RootLayout({ children }: Readonly<{ children: React.ReactNode; }>) {
		  return (
		    <html lang="es">
		      <body
		        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
		      >
		        <Provider store={store}>
		          {children}
		        </Provider>
		      </body>
		    </html>
		  );
		}

	Pero esto va a dar error, porque el Provider debe generarse del lado del cliente. Tampoco se puede usar 'use-client' en la parte superior porque tambi칠n da error

	Soluci칩n:
		1) En la carpeta /app/store crear un nuevo archivo "Providers.tsx"
			'use-client'

			import { Provider } from "react-redux"
			import { store } from './index';
	
			interface Props {
			    children: React.ReactNode
			}

			export const Providers = ({children}: Props) => {
			    return (
			        <Provider store={store}>
			            {children}
			        </Provider>
			    )
			}

		2) Importar ese Providers.tsx en el layout y envolver toda la aplicaci칩n:
			import { Providers } from "@/store/Providers";

			export default function RootLayout({ children }: Readonly<{ children: React.ReactNode; }>) {
			  return (
			    <html lang="es">
			      <body
			        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
			      >
			          <Providers>
			            {children}
			          </Providers>
			      </body>
			    </html>
			  );
			}

		3) As칤 tiene que quedar el store:
			import { configureStore } from '@reduxjs/toolkit'

			import counterReducer from './counter/counterSlice'
			import { useDispatch, useSelector } from 'react-redux'

			export const store = configureStore({
			  reducer: {
			    counterReducer,
			  },
			})

			export type RootState = ReturnType<typeof store.getState>
			export type AppDispatch = typeof store.dispatch

			export const useAppDispatch = useDispatch.withTypes<AppDispatch>() // <---- Agregar!
			export const useAppSelector = useSelector.withTypes<RootState>()   // <---- Agregar!





Puedo tener APIs (backend) en cualquier lugar del proyecto, pero para mejor orden se prefiere seguir manejandolo en /app/api/[ENDPOINT]
	* En el ejemplo, cre칠 carpeta /app/api/counter
		* Agregar un archivo route.ts y llenarlo con:
			export async function GET() {
			    return Response.json({ count: 100 })
			}

Refrescar la ruta actualizando solo los componentes que cambiaron: 10/134
	const router = useRouter()
	router.refresh()


SERVER ACTIONS! (Secci칩n 11)
	Son actualizaciones de la base de datos sin usar API REST

	Se pueden llamar del lado del cliente, desde un componente con 'use client'

	Para esto, puedo tener un archivo que empiece con 'use server', eso hace que todas las funciones de ese archivo corran del lado del servidor, o bien puedo hacer solo una funci칩n en un archivo de esta manera:
		export const miFuncion = () => {
			'use server' // <--- Esto de ac치 la convierte en una funci칩n del servidot
		}

	Implementaciones de ABM con Server Actions (sin pasar por API Rest)
		export const toggleTodo = async (id: string, complete: boolean): Promise<Todo> => {
		    const todo = await prisma.todo.findFirst({ where: {id} })

		    if(!todo){
		        throw `Todo con id ${id} no encontrado`
		    }

		    const updatedTodo = await prisma.todo.update({
		        where: {id},
		        data: {complete: complete}
		    })

		    revalidatePath('/dashboard/server-todos')
		    return updatedTodo
		}

		export const addTodo = async(description: string) => {
		    try {
		        // const {complete, description} = await postSchema.validate(await request.json())
		        const todo = await prisma.todo.create({data: { description } })

		        revalidatePath('/dashboard/server-todos')
		        return todo
		    }catch(error){
		        return {
		            message: "Error creando todo"
		        }
		    }
		}

		export const deleteCompleted = async():Promise<void> => {
		    await prisma.todo.deleteMany({where: {complete: true}})

		    revalidatePath('/dashboard/server-todos')
		}
	

useOptimistic Hook 11/145
	Similar a useState
	
	Devuelve una respuesta visual al usuario (similar a useState), como si ya hubiera actualizado los cambios, pero en realidad manda a llamar a la actualizaci칩n por detras
	Para el usuario "parece" que se actualiz칩 inmediatamente, pero en realidad cambia visualmente, y en ese momento dispara la actualizaci칩n al server

Revalidaci칩n de la data 11/146
	Si no estamos trabajando con fetch, donde se le puede configurar el no cache, se puede usar la siguiente sintaxis al inicio del componente para configurar si queremos o no cach칠:
	
	export const dynamic = 'force-dynamic' // <--- Sin cach칠

	OJO: Esto aplica para Page, Layout o Route Handler

Uso de Cookies
	Para manejo del lado del cliente se instala un paquete 12/154
		npm install --save cookies-next

	El uso es:
		import { setCookie } from "cookies-next"
		(...)
		setCookie('selectedTab', variable.toString()) // <--- Se tiene que guardar un string

	Manejar cookies del lado del servidor 12/155
		import { cookies } from "next/headers";
		(...)
		const cookieStore = await cookies() // <--- OJO! En el curso no tiene await (por ah칤 es porque es una versi칩n anterior)
		const cookieTab = Number(cookieStore.get('selectedTab')?.value ?? '1')

	OJO! Las cookies son manejables desde el lado del cliente, el cliente puede manipular las cookies desde el navegador
	



AVERIGUAR:
	Diferencias entre:
		const router = useRouter()
		router.refresh()
	Y
		revalidatePath('/dashboard/server-todos')